% \documentclass{article}
% \usepackage{amssymb}
% \usepackage{amsmath}
% \usepackage{amsthm}
% \usepackage{amsfonts}
% \usepackage{stmaryrd}
% \usepackage{dsfont}
% \usepackage{xfrac}
% \usepackage{mathrsfs}
% \usepackage{xcolor}

% \begin{document}

\section{Propositional (Boolean) Logic}
In propositional (Boolean) Logic we differentiate between:
\begin{itemize}
    \item Syntax (Proof theory) where we look at strings of letters, e.g.  $ a, b, A, B, \# $, in a concrete syntax.
    \item  Semantics (Model Theory) where we look at boolean ($\BN\coloneqq \{\true,\false \}$) functions (gates) $f\colon \BN^n\to \BN$.
\end{itemize}

\begin{center}
    \begin{tabular}{|c|c|c|c|c|}
\hline
$A$ & $B$ & $A \land B$  & $A \lor B$ & $\neg A$\\
\hline
$0$ & $0$ & $0$ & $0$ & $1$ \\
$0$ & $1$ & $0$ & $1$ & $1$ \\
$1$ & $0$ & $0$ & $1$ & $0$ \\
$1$ & $1$ & $1$ & $1$ & $0$ \\
\hline
\end{tabular}
\end{center}






% \paragraph{Syntax} The realm of Proof Theory 
% \textbf{Semantics} (Model Theory)
% \begin{itemize}
%     \item $ B = \{ \text{true, false} \} $
%     \item Boolean functions (gates) $ f: B^n \rightarrow B $
% \end{itemize}

% \textbf{Syntax} (Proof Theory)
% - A string of letters: $ a, b, A, B, \# $, ...
% - (concrete syntax)

% \textbf{Symbols}
% - $ \neg, \wedge, \vee, \rightarrow, \leftrightarrow $
% - $ \land, \lor $ (alternative notation)
% - \textit{connectives}

% \textbf{Given a set of $ P = \{ p_0, p_1, p_2, ..., p_n \} $ of propositions}
% - Induce the set $ \mathcal{O} $ of all (well-formed) formulas

% $\varphi = p \mid \neg \varphi \mid ( \varphi \wedge \psi ) \mid ( \varphi \vee \psi ) \mid ( \varphi \rightarrow \psi )$

% \textbf{For a model set $ X $ generated by the following rules:}
% - $ x \vDash p $ if $ p \in x $
% - $ x \vDash \neg \varphi $ if not $ x \vDash \varphi $
% - $ x \vDash \varphi \wedge \psi $ if $ x \vDash \varphi $ and $ x \vDash \psi $
% - $ x \vDash \varphi \vee \psi $ if $ x \vDash \varphi $ or $ x \vDash \psi $
% - $ x \vDash \varphi \rightarrow \psi $ if not $ x \vDash \varphi $ or $ x \vDash \psi $

% \textbf{Abstract syntax}
% - $ T \mid F \mid p \mid \neg \varphi \mid \varphi \wedge \psi \mid \varphi \vee \psi \mid \varphi \rightarrow \psi $

% \textbf{Inference rules}
% - From $ \varphi $ infer $ \neg \neg \varphi $


\begin{definition}[Syntax]
    Given a finite set  $P = \{p_0, p_1, ..., p_n\}$ of propositions.
We define the set $ \Phi $ of (well-formed) formulas (countable).
\begin{align*}
    \varphi \Coloneqq P \mid \top \mid \bot \mid \neg \varphi \mid (\varphi \wedge \psi) \mid (\varphi \vee \psi) \mid (\varphi \simplies \psi)
\end{align*}
\end{definition}


\begin{remark}
    The definition is inductive. That is, $\Phi$ is the smallest set $ X $ generated by the following rules creating an abstract syntax tree:
 \begin{center}
    \AxiomC{}
    \RightLabel{\tiny$p\in P$}
    \UnaryInfC{$p$}
    \DisplayProof
    $\quad$
       \AxiomC{}
    \UnaryInfC{$\bot$}
    \DisplayProof
    $\quad$
    \AxiomC{}
    \UnaryInfC{$\top$}
    \DisplayProof
    $\quad$
    \AxiomC{$\varphi$}
    \UnaryInfC{$\neg\varphi$}
    \DisplayProof
    $\quad$
    \AxiomC{$\varphi_1$}
    \AxiomC{$\varphi_2$}
    \BinaryInfC{$\varphi_1 \land \varphi_2$}
    \DisplayProof
    $\quad$
    \AxiomC{$\varphi_1$}
    \AxiomC{$\varphi_2$}
    \BinaryInfC{$\varphi_1 \lor \varphi_2$}
    \DisplayProof
    $\quad$
    \AxiomC{$\varphi_1$}
    \AxiomC{$\varphi_2$}
    \BinaryInfC{$\varphi_1 \simplies \varphi_2$}
    \DisplayProof
  \end{center}
\end{remark}

\begin{remark}
    The presence order is implied by the order of the rules, e.g. $\neg a \lor b\land c \equiv  \neg a \lor (b\land c)$
    Binary connectives are right associative, e.g., 
    $ a \land b \land c \equiv   a \land (b \land c)$ or $ a \simplies b \simplies c \equiv   a \simplies (b \simplies c)$
    The connective $\siff$ is syntactic sugar for $(\varphi \simplies \psi) \lor (\psi \simplies \varphi)$.
\end{remark}


% $ p \in X $; 
% $ \bot, \top \in X $;
% $ \neg \varphi \in X $ if $ \varphi \in X $;
% $ \varphi_1 \wedge \varphi_2, \varphi_1 \vee \varphi_2, \varphi_1 \Rightarrow \varphi_2 \in X $ if $ \varphi_1, \varphi_2 \in X $.

% $\varphi \Leftrightarrow \psi$ is an abbreviation for
% $$.

\begin{definition}[Semantics]
    Let $ \valfoo: P \rightarrow \mathbb{B}$ be a truth assignment and let $V = \mathbb{B}^P$. Then we define an interpretation $\eval{\cdot}\colon \Phi \times V \to \BN$ as follows:
    \begin{itemize}
        \item $\eval{p}_{\valfoo} = \valfoo(p)$,  $\eval{\bot}_{\valfoo} = \false$,
        $\eval{\bot}_{\valfoo} = \true$;
        \item $\eval{\neg\varphi}_{\valfoo} =$ if $\eval{\neg\varphi}_{\valfoo}=\true$ then $\false$ else $\true$;
        \item $\eval{\varphi_1 \land \varphi_2}_{\valfoo}=$ if $\eval{\varphi_1}_{\valfoo}=\true$ and $\eval{\varphi_2}_{\valfoo}=\true$ then $\true$ else $\false$;
        \item $\eval{\varphi_1 \lor \varphi_2}_{\valfoo}=$ if $\eval{\varphi_1}_{\valfoo}=\true$ or $\eval{\varphi_2}_{\valfoo}=\true$ then $\true$ else $\false$;
        \item $\eval{\varphi_1 \simplies \varphi_2}_{\valfoo}=$ if $\eval{\varphi_1}_{\valfoo}=\true$ or $\eval{\varphi_2}_{\valfoo}=\false$ then $\false$ else $\true$;
        \end{itemize}
\end{definition}

\begin{definition}[Model, Satisfiable, Validity]
    The truth assignment $\valfoo$ is called a \emph{model} of $\varphi$ if $\eval{\varphi}_{\valfoo}=\true$, written using entailment as $ \valfoo \models \varphi$.
    The formula $\varphi$ is \emph{satisfiable}, if $\exists \valfoo\in V : \valfoo \models \varphi$.
    The formula $\varphi$ is \emph{valid}, if $\forall \valfoo\in V : \valfoo \models \varphi$, written as $\models \varphi$.
\end{definition}

\begin{definition}[Problems in Logic]
The common problems in logic are:
    \begin{itemize}
    \item the \emph{evaluation problem}: given $\varphi$ and $\valfoo$, find $\eval{\varphi}_{\valfoo}$. It can be solved in linear time.
    \item the \emph{validity problem}: given $\varphi$, is $\varphi$ valid? It is co-NP-complete.
    \item the \emph{satisfiability problem (SAT)}: given $\varphi$, is $\varphi$ satisfiable? It is NP-complete.
\end{itemize}
For propositional logic, these problems are dual: $\varphi$ is valid iff $\neg\varphi$ is unsatisfiable.
\end{definition}


\begin{definition}[Soundness]
    An algorithm (not necessarily halting) to solve satisfiability with input $\varphi$ and output $\BN$  is sound iff: (i) If output is $\true$, then $\varphi$ is satisfiable. (ii) If the output is $\false$, then $\varphi$ is unsatisfiable.
\end{definition}


\begin{definition}[Complete]
    An algorithm to solve satisfiability with input $\varphi$ and output $\BN$  is \emph{semi-complete} iff (i) if $\varphi$ is satisfiable, then the algorithm halts with output true.
    The algorithm is \emph{complete} if (i) and (ii) 
    if $\varphi$ is unsatisfiable, then the algorithm halts with false.
    It is called a \emph{decision procedure}.
\end{definition}


\begin{remark}[SAT Solvers]
    Decision procedures for propositional logic are called SAT Solvers. SAT solvers typically first transform $\varphi$ into CNF (Conjunctive Normal Form): (i) conjunction of clauses,(ii) each clause is a disjunction of literals, and (iii) each literal is a proposition or its negation.
\end{remark}


\begin{definition}[SAT Solver: Exhaustive Search]
On possibility is to enumerate all possible $2^n$ interpretations of the $n$ propositions. 
Let $\Gamma$ be a set of formulas and let $\Gamma[p]$ denote all occurrences of $p$ in $\Gamma$ then we define the rule
\begin{center}
    \AxiomC{$\Gamma [\bot]$ $\;\unsat$}
    \AxiomC{$\Gamma[\top]$ $\;\unsat$}
    \BinaryInfC{$\Gamma [p]$ $\;\unsat$}
    \DisplayProof 
    $\quad \quad $
    \AxiomC{$\Gamma[\top]$ $\;\unsat$}
    \UnaryInfC{$\Gamma, \bot$ $\;\unsat$}
    \DisplayProof
\end{center}
\end{definition}


\begin{definition}[SAT Solver: Resolution]
The resolution rule is
\begin{center}
    \AxiomC{$\Gamma, C_1[\bot] \lor C_2[\top]$ $\; \unsat$}
    \UnaryInfC{$\Gamma, C_1[p] , C_2[\neg p]$ $ \; \unsat$}
    \DisplayProof
\end{center}
\end{definition}


\begin{exercise}
    Show that resolution is sound and complete.
\end{exercise}



% Define $ \llbracket \rrbracket: \Phi \times V \rightarrow \mathbb{B}$ as:
% \[
% \begin{aligned}
%     % \llbracket \varphi \rrbracket_v &= \text{ truth value} \\
%     \llbracket p \rrbracket_v &= v(p) \\
%     \llbracket \bot \rrbracket_v &= \text{false} \\
%     \llbracket \top \rrbracket_v &= \text{true} \\
%     \llbracket \neg \varphi \rrbracket_v &= \text{if } \llbracket \varphi \rrbracket_v = \text{true then false else true} \\
%     \llbracket \varphi_1 \wedge \varphi_2 \rrbracket_v &= \text{if } \llbracket \varphi_1 \rrbracket_v = \text{true and } \llbracket \varphi_2 \rrbracket_v = \text{true then true else false} \\
%     \llbracket \varphi_1 \vee \varphi_2 \rrbracket_v &= \text{if } \llbracket \varphi_1 \rrbracket_v = \text{false and } \llbracket \varphi_2 \rrbracket_v = \text{false then false else true} \\
%     \llbracket \varphi_1 \Rightarrow \varphi_2 \rrbracket_v &= \text{if } \llbracket \varphi_1 \rrbracket_v = \text{true and } \llbracket \varphi_2 \rrbracket_v = \text{false then false else true} 
%     % The expression for if-else is a bit unclear, it could be written as conditional expression in a proper way.
% \end{aligned}
% \]

% $v \models \varphi$ iff $\llbracket \varphi \rrbracket_v = \text{true}$. Say $v$ is a model of $\varphi$.

% $\models \varphi$ iff $\forall v, \text{ } \llbracket \varphi \rrbracket_v$. Say $\varphi$ is valid.

% $\exists v, \text{ } v \models \varphi$. Say $\varphi$ is satisfiable.

% \subsection*{Problems in Logic}



% \subsection*{Sound/Semi-complete/Complete}


% An algorithm (not necessarily halting) to solve satisfiability that inputs $\varphi$ and outputs $\mathbb{B}$ is semi-complete iff
% \begin{itemize}
%     \item If $\varphi$ is satisfiable, then the algorithm halts with output true.
% \end{itemize}

% An algorithm to solve satisfiability that inputs $\varphi$ and outputs $\mathbb{B}$ is complete iff
% \begin{itemize}
%     \item If $\varphi$ is satisfiable, then the algorithm halts with output true.
%     \item If $\varphi$ is unsatisfiable, then the algorithm halts with false.
% \end{itemize}

% \section{SAT Solvers}

% \begin{enumerate}
%     \item Exhaustive search - evaluate all $2^n$ interpretations of $n$ propositions.
% \end{enumerate}



% Examples:
% \begin{itemize}
%     \item $\{\neg a \vee b \vee c, \neg b \vee c, c \vee d\}$
%     \item $\{\neg b \vee c, b \vee c, c \vee d\}$

% \end{itemize}

% {\color{red}
% \begin{enumerate}
%     \item Exhaustive search - apply rules
%     \[
%     \begin{aligned}
%         \Gamma \vdash \varphi &\text{ unsat} \\
%         \Gamma \vdash \neg \varphi &\text{ unsat}
%     \end{aligned}
%     \]
%     \item Resolution
%     \[
%     \begin{aligned}
%         \Gamma, C_1 \left[ \varphi \right] \vee C_2 \left[ \neg \varphi \right] &\text{ unsat} \\
%         \Gamma, C \left[ P \right], C \left[ \neg P \right] &\text{ unsat}
%     \end{aligned}
%     \]
%     % ... (The rest of the document would continue with more content)
% \end{enumerate}
% }

% \subsection{Exhaustive search}

% \[

% \]

% \subsection{Resolution}

% \[
% \frac{\Gamma, \text{ } C_1[\bot]\vee C_2[\bot] \text{ unsat}}{\Gamma, \text{ } C_1[p], \text{ } C_2[\neg p] \text{ unsat}}
% \]

% \end{document}
